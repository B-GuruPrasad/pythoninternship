# oops 
class bikes:
    def perf(self):
        print("gt","650",14,5)
gt=bikes()
duke=bikes()
gt.perf()
duke.perf()

class bikes:
    def __init__(self,name,cc,m,cost):
        self.name=name
        self.cc=cc
        self.m=m
        self.cost=cost
    def performance(self):
        print("abt bikes:",self.name,self.cc,self.m,self.cost)
gt=bikes("gt",650,12,4)
duke=bikes("duke",390,25,2)
gt.performance()
duke.performance()


class method and static method
class cars:
    wheels=4
    def __init__(self,mil,car):
        self.mil=mil
        self.car=car
    def get_mil(self):
        return c1.mil
    def set_mil(self):
        c1.mil=12
        return c1.mil
    @staticmethod
    def inf0():
        print("hi hello")
    @classmethod
    def infor(cls):
        return cls.wheels
print(cars.infor())
c1=cars(10,"BMW")
c2=cars(15,"audi")
c1.wheels=9
print(c1.mil)
print(c1.wheels)
print(c2.wheels)
print(c1.get_mil())
print(c1.set_mil())
print(c1.mil)


class pycharm:
    def execute(self):
        print("compiling")
        print("running")
class myeditor:
    def execute(self):
        print("debugging")
        print("printing error")
        print("compling")
        print("running")
class laptop:
    def code(self,ide):
        ide.execute()
ide=pycharm()
lap1=laptop()
lap1.code(ide)


# operator overloading
class student:
    def __init__(self,m1,m2):
        self.m1=m1
        self.m2=m2
    def __add__(self,other):
        m1=self.m1+other.m2
        m2=self.m2+other.m2
        s3=student(m1,m2)
        return s3
    def __gt__(self,other):
        r1=self.m1+self.m2
        r2=other.m1+other.m2
        if r1>r2:
            return True
        else:
            return False
s1=student(59,65)
s2=student(67,85)
s3=s1+s2
print(s3.m1)
print(s3.m2)
if s1>s2:
    print("s1 is having more then s2")
else:
    print("s2 is having more then s1")

# method overloading
class math:
    def add(self,a=0,b=0,c=0):
        return a+b+c
m=math()
print(m.add(1,2))
print(m.add(1,2,3))
print(m.add())



# inheritance
single level inheritance
class animal:
    def sound(self):
        return "animal make difference sounds"
class dog(animal):
    def s(self):
        return "dog barks"
d=dog()
print(d.sound())
print(d.s())



# multiple inheritance
class engine:
    def engine_info(self):
        return "this is an engine"
class wheels:
    def wheels_info(self):
        return "car has 4 wheels"
class car(engine,wheels):
    def car_info(self):
        return "this a car"
c=car()
print(c.engine_info())
print(c.wheels_info())
print(c.car_info())


# multi level inheritance
class animal:
    def species(self):
        return "this is an animal"
class mammal(animal):
    def category(self):
        return "this is an mammal"
class human(mammal):
    def speak(self):
        return "humans can speak"
h=human()
print(h.species())
print(h.category())
print(h.speak())


# hierarchical inheritance
class vehicle:
    def fuel_type(self):
        return "vehicle can use petrol,disel and lpg"
class car(vehicle):
    def type(self):
        return "car is a 4-wheels"
class bike(vehicle):
    def type(self):
        return "bike is a 2 wheels"
c=car()
b=bike()
print(c.fuel_type())
print(b.type())
print(c.type())


# hybride inheritance
class A:
    def display(self):
        print("display from A class")
class B(A):
    def display(self):
        print("display from B class")
class C:
    def show(self):
        print("hi from C class")
class D(B,C):
    def display(self):
        print("display from D class")
d1=D()
d1.display()
d1.show()
print(D.mro())


# abstraction 





# linear searching
arr=[7,5,1,3,8,9,2,6]
key=2
for i in range(len(arr)):
    if (arr[i])==key:
        print("element found at index:",i)
        break
else:
    print("element not found:",-1)


# linear search in function
def search(arr,key):
    for i in range (len(arr)):
        if (arr[i])==key:
            print("element found at index:",i)
            break
    else:
        print("element not found:",-1)   
arr=[7,5,1,3,8,9,2,6]
key=int(input("enter number:"))
search(arr,key)


arr=[1,2,3,5,8,10,11,12]
key=11
low=0
low,high=0,len(arr)-1
def binary_search(arr,key,low,high):
    if low<high:
        mid=(low+high)/2
    if arr[mid]==key:
        res= mid
    elif arr[mid]<key:
        low=mid+1
    else:
        high=mid-1
print(res)





# searching the 1st and last occurence
def binary_search(arr,key,low,high):
    if low<=high:
        mid=(low+high)//2
        if (arr[mid])==key:
            if arr[mid-1]==key:
                return binary_search(arr,key,mid+1,high)
            else:
                return mid
        elif arr[mid]<key:
            return binary_search(arr,key,mid+1,high)
        elif arr[mid]>key:
            return binary_search(arr,key,low,mid-1)
    else:
        return -1
arr=[1,2,3,3,4,5,6,7]
key=3
res=binary_search(arr,key,0,len(arr))
print(res)




# roated sorted array
l=[5,6,7,0,1,2,3]
low,high=0,len(l)-1
while low<high:
    mid=(low+high)//2
    if l[mid]>l[high]:
        low=mid+1
    else:
        high=mid
print(l[low])




# peak elements(neighbours must be lesser)
l=[1,2,3,5,1]
low,high=0,len(l)-1
while low<high:
    mid=(low+high)//2
    if l[mid]<l[mid+1]:
        low=mid+1
    else:
        high=mid
print(l[low])




n=16
low,high=0,n
res=0
while low<=high:
    mid=(low+high)//2
    if mid*mid<=n:
        res=mid
        low=mid+1
    else:
        high=mid-1
print(res)
